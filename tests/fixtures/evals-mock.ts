import { Page } from '@playwright/test';

/**
 * Mock data for eval generation/execution tests
 *
 * Uses Playwright route mocking to intercept API calls and return mock responses,
 * allowing tests to run without actual LLM calls.
 */

// Mock eval code that would be generated by LLM
export const MOCK_EVAL_CODE = `def eval_response_quality(trace: dict) -> tuple[bool, str]:
    """Evaluates response quality based on trace data."""
    steps = trace.get('steps', [])
    if not steps:
        return False, "No steps found in trace"

    last_step = steps[-1]
    output = last_step.get('output', {})
    response = output.get('response', '')

    if len(response) < 10:
        return False, "Response too short"

    return True, "Response meets quality criteria"
`;

// Mock job that completes immediately
export function createMockJob(jobId: string, type: string = 'generate') {
  return {
    id: jobId,
    type,
    status: 'completed',
    progress: 100,
    result: type === 'generate' ? {
      eval_id: `eval_mock_${Date.now()}`,
      accuracy: 0.85,
      test_results: {
        correct: 8,
        incorrect: 2,
        errors: 0,
        total: 10,
        details: [],
      },
    } : {
      accuracy: 0.90,
      passed: 9,
      failed: 1,
      errors: 0,
      total: 10,
    },
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };
}

// Mock eval data
export function createMockEval(evalId: string, evalSetId: string, name: string) {
  return {
    id: evalId,
    eval_set_id: evalSetId,
    name,
    description: 'Mock eval for testing',
    code: MOCK_EVAL_CODE,
    model_used: 'claude-sonnet-4.5',
    accuracy: 0.85,
    version: 1,
    execution_count: 0,
    contradiction_count: 0,
    test_results: {
      correct: 8,
      incorrect: 2,
      errors: 0,
      total: 10,
    },
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };
}

// Mock matrix response (for contradiction testing)
export function createMockMatrix(evalId: string, traceIds: string[]) {
  return {
    eval_ids: [evalId],
    rows: traceIds.map((traceId, index) => ({
      trace_id: traceId,
      human_feedback: index < 3 ? 'positive' : 'negative',
      eval_result: index < 4 ? 'pass' : 'fail',
      match: index < 3 || index >= 4,
      reason: index < 4 ? 'Passed quality check' : 'Failed quality check',
    })),
    summary: {
      total: traceIds.length,
      matches: traceIds.length - 1,
      contradictions: 1,
      accuracy: ((traceIds.length - 1) / traceIds.length) * 100,
    },
  };
}

/**
 * Setup route mocking for eval generation job API
 *
 * Intercepts:
 * - POST /api/eval-sets/:id/generate → returns mock job
 * - GET /api/jobs/:id → returns completed job
 * - GET /api/evals → returns mock evals list
 * - GET /api/evals/:id → returns mock eval detail
 */
export async function setupEvalGenerationMocks(
  page: Page,
  options: {
    evalSetId: string;
    evalName?: string;
    traceIds?: string[];
  }
): Promise<{ evalId: string; jobId: string }> {
  const jobId = `job_mock_${Date.now()}`;
  const evalId = `eval_mock_${Date.now()}`;
  const evalName = options.evalName || 'Test Eval';

  // Mock POST /api/eval-sets/:id/generate
  await page.route(`**/api/eval-sets/${options.evalSetId}/generate`, async (route) => {
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({ job_id: jobId }),
    });
  });

  // Mock GET /api/jobs/:id - return completed job
  await page.route(`**/api/jobs/${jobId}`, async (route) => {
    const job = createMockJob(jobId, 'generate');
    job.result = { ...job.result, eval_id: evalId };
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify(job),
    });
  });

  // Mock GET /api/evals (list)
  await page.route('**/api/evals?**', async (route) => {
    const mockEval = createMockEval(evalId, options.evalSetId, evalName);
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({
        evals: [mockEval],
        total: 1,
      }),
    });
  });

  // Mock GET /api/evals/:id (detail)
  await page.route(`**/api/evals/${evalId}`, async (route) => {
    if (route.request().method() === 'GET') {
      const mockEval = createMockEval(evalId, options.evalSetId, evalName);
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(mockEval),
      });
    } else {
      await route.continue();
    }
  });

  return { evalId, jobId };
}

/**
 * Setup route mocking for eval execution
 */
export async function setupEvalExecutionMocks(
  page: Page,
  options: {
    evalId: string;
    evalSetId: string;
    evalName?: string;
  }
): Promise<{ jobId: string }> {
  const jobId = `job_exec_mock_${Date.now()}`;
  const evalName = options.evalName || 'Test Eval';

  // Mock POST /api/evals/:id/execute
  await page.route(`**/api/evals/${options.evalId}/execute`, async (route) => {
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({ job_id: jobId }),
    });
  });

  // Mock GET /api/jobs/:id - return completed execution job
  await page.route(`**/api/jobs/${jobId}`, async (route) => {
    const job = createMockJob(jobId, 'execute');
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify(job),
    });
  });

  // Update eval mock with execution results
  await page.route(`**/api/evals/${options.evalId}`, async (route) => {
    if (route.request().method() === 'GET') {
      const mockEval = createMockEval(options.evalId, options.evalSetId, evalName);
      mockEval.execution_count = 1;
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(mockEval),
      });
    } else {
      await route.continue();
    }
  });

  return { jobId };
}

/**
 * Setup route mocking for eval results/matrix viewing
 */
export async function setupEvalResultsMocks(
  page: Page,
  options: {
    evalId: string;
    evalSetId: string;
    traceIds: string[];
    evalName?: string;
    hasContradictions?: boolean;
  }
): Promise<void> {
  const evalName = options.evalName || 'Test Eval';

  // Mock GET /api/evals/:id
  await page.route(`**/api/evals/${options.evalId}`, async (route) => {
    if (route.request().method() === 'GET') {
      const mockEval = createMockEval(options.evalId, options.evalSetId, evalName);
      mockEval.execution_count = 1;
      if (options.hasContradictions) {
        mockEval.contradiction_count = 1;
        mockEval.accuracy = 0.83;
      }
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(mockEval),
      });
    } else {
      await route.continue();
    }
  });

  // Mock GET /api/eval-sets/:id/matrix
  await page.route(`**/api/eval-sets/${options.evalSetId}/matrix**`, async (route) => {
    const matrix = createMockMatrix(options.evalId, options.traceIds);
    if (!options.hasContradictions) {
      // Make all rows match
      matrix.rows = matrix.rows.map(row => ({ ...row, match: true }));
      matrix.summary.contradictions = 0;
      matrix.summary.matches = matrix.summary.total;
      matrix.summary.accuracy = 100;
    }
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify(matrix),
    });
  });
}

/**
 * Clear all route mocks
 */
export async function clearEvalMocks(page: Page): Promise<void> {
  await page.unrouteAll({ behavior: 'wait' });
}
